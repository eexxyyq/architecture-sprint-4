# Архитектурное решение по кешированию

## Мотивация

Операторы MES жалуются на низкую скорость работы с веб-страницей, что негативно сказывается на производительности и, в конечном итоге, на удовлетворенности клиентов. Время выполнения заказа также остается недостаточно быстрым, что приводит к недовольству новых клиентов. Для решения этих проблем необходимо внедрить кеширование в систему.

### Проблемы, которые должны быть решены с помощью кеширования:
1. **Снижение нагрузки на сервер**: Прямые запросы к базе данных для получения информации о заказах замедляют работу. Частые запросы за одинаковыми данными можно кешировать.
2. **Ускорение времени отклика**: Снижение времени ответа для пользователей и операторов, улучшение их опыта работы с системой.
3. **Оптимизация работы с часто запрашиваемыми данными**: Например, список заказов, статусы, модели, которые не изменяются так часто, но часто запрашиваются.

### Элементы системы для кеширования:
1. **Список заказов** — это данные, которые могут быть нечасто изменяемыми, но часто запрашиваемыми.
2. **Статусы заказов** — могут быть обновлены только в определенные моменты времени (например, при изменении статуса заказа), что делает их подходящими для кеширования.

## Предлагаемое решение

### Виды кеширования
Для решения проблемы с производительностью мы будем использовать **серверное кеширование**, поскольку оно предоставляет лучший контроль над хранением и обновлением данных, а также позволяет избежать перегрузки клиентов.

#### Почему серверное кеширование?
- **Концентрация кеша на сервере** позволяет легче управлять данными, следить за их актуальностью и централизованно контролировать кеш.
- **Управление инвалидацией кеша** в серверном кешировании значительно проще и гибче, чем в клиентском.

### Паттерн кеширования
**Cache-Aside**: данные загружаются в кеш только по запросу, если их нет в кеше, система обращается к базе данных и добавляет результат в кеш. Это решает проблему загрузки редко меняющихся данных.

#### Почему Cache-Aside:
- **Контроль над данными**: Мы имеем полный контроль над тем, когда данные должны быть загружены в кеш.
- **Гибкость при инвалидации кеша**: Легче контролировать срок хранения данных и запускать обновление кеша при необходимости.

#### Почему не выбраны другие паттерны:
- **Write-Through**: Кеш автоматически обновляется при каждом запросе в базу данных, что может привести к дополнительной нагрузке на базу данных и потере эффективности.
- **Refresh-Ahead**: Этот паттерн может быть полезен для данных, которые часто обновляются, но для данных типа заказов это не так актуально, так как их изменения происходят не так часто.

### Стратегия инвалидации кеша
Для кеширования будем использовать **инвалидацию по ключу**:
- При изменении статуса заказа или данных о заказах в базе данных кеш будет очищаться по ключу, который связан с этим заказом. Это гарантирует, что кеш будет всегда актуален и не будет хранить устаревшую информацию.
- **Почему не подходит временная инвалидация**: Временная инвалидация будет слишком грубой для нашей задачи, так как не все данные изменяются по расписанию.
- **Почему не подходит программная инвалидация**: Программная инвалидация слишком сложная в настройке и может привести к дополнительным трудозатратам.

## Диаграмма последовательности действий (Sequence Diagram)

[solution.puml](solution.puml)
